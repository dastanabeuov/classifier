
indexer
{
}

searchd
{
  listen = 127.0.0.1:9307:mysql41
  log = /home/adk/classifier/log/test.searchd.log
  query_log = /home/adk/classifier/log/test.searchd.query.log
  pid_file = /home/adk/classifier/log/test.sphinx.pid
  workers = threads
  binlog_path = /home/adk/classifier/tmp/binlog/test
}

source activity_core_0
{
  type = pgsql
  sql_host = localhost
  sql_user = postgres
  sql_pass = 123456
  sql_db = classifier_test
  sql_query_pre = SET TIME ZONE UTC
  sql_query = SELECT "activities"."id" * 12 + 0 AS "id", "activities"."title" AS "title", "activities"."synonym" AS "synonym", "activities"."description" AS "description", "activities"."code" AS "code", "activities"."id" AS "sphinx_internal_id", 'Activity' AS "sphinx_internal_class", 0 AS "sphinx_deleted", extract(epoch from "activities"."version_date")::int AS "version_date", "activities"."publish" AS "publish", "activities"."position" AS "position", "activities"."ancestry" AS "ancestry", "activities"."user_id" AS "user_id", extract(epoch from "activities"."created_at")::int AS "created_at", extract(epoch from "activities"."updated_at")::int AS "updated_at" FROM "activities" WHERE ("activities"."id" BETWEEN $start AND $end) GROUP BY "activities"."id", "activities"."title", "activities"."synonym", "activities"."description", "activities"."code", "activities"."id", "activities"."version_date", "activities"."publish", "activities"."position", "activities"."ancestry", "activities"."user_id", "activities"."created_at", "activities"."updated_at"
  sql_query_range = SELECT COALESCE(MIN("activities"."id"), 1), COALESCE(MAX("activities"."id"), 1) FROM "activities"
  sql_attr_uint = sphinx_internal_id
  sql_attr_uint = sphinx_deleted
  sql_attr_uint = version_date
  sql_attr_uint = user_id
  sql_attr_uint = created_at
  sql_attr_uint = updated_at
  sql_attr_bool = publish
  sql_attr_string = sphinx_internal_class
  sql_attr_string = position
  sql_attr_string = ancestry
  sql_field_string = title
}

index activity_core
{
  type = plain
  path = /home/adk/classifier/db/sphinx/test/activity_core
  source = activity_core_0
}

source property_core_0
{
  type = pgsql
  sql_host = localhost
  sql_user = postgres
  sql_pass = 123456
  sql_db = classifier_test
  sql_query_pre = SET TIME ZONE UTC
  sql_query = SELECT "properties"."id" * 12 + 1 AS "id", "properties"."title" AS "title", "properties"."id" AS "sphinx_internal_id", 'Property' AS "sphinx_internal_class", 0 AS "sphinx_deleted", "properties"."activity_id" AS "activity_id", extract(epoch from "properties"."created_at")::int AS "created_at", extract(epoch from "properties"."updated_at")::int AS "updated_at" FROM "properties" WHERE ("properties"."id" BETWEEN $start AND $end) GROUP BY "properties"."id", "properties"."title", "properties"."id", "properties"."activity_id", "properties"."created_at", "properties"."updated_at"
  sql_query_range = SELECT COALESCE(MIN("properties"."id"), 1), COALESCE(MAX("properties"."id"), 1) FROM "properties"
  sql_attr_uint = sphinx_internal_id
  sql_attr_uint = sphinx_deleted
  sql_attr_uint = activity_id
  sql_attr_uint = created_at
  sql_attr_uint = updated_at
  sql_attr_string = sphinx_internal_class
  sql_field_string = title
}

index property_core
{
  type = plain
  path = /home/adk/classifier/db/sphinx/test/property_core
  source = property_core_0
}

source user_core_0
{
  type = pgsql
  sql_host = localhost
  sql_user = postgres
  sql_pass = 123456
  sql_db = classifier_test
  sql_query_pre = SET TIME ZONE UTC
  sql_query = SELECT "users"."id" * 12 + 2 AS "id", "users"."email" AS "email", "users"."role" AS "role", "users"."id" AS "sphinx_internal_id", 'User' AS "sphinx_internal_class", 0 AS "sphinx_deleted", extract(epoch from "users"."created_at")::int AS "created_at", extract(epoch from "users"."updated_at")::int AS "updated_at" FROM "users" WHERE ("users"."id" BETWEEN $start AND $end) GROUP BY "users"."id", "users"."email", "users"."role", "users"."id", "users"."created_at", "users"."updated_at"
  sql_query_range = SELECT COALESCE(MIN("users"."id"), 1), COALESCE(MAX("users"."id"), 1) FROM "users"
  sql_attr_uint = sphinx_internal_id
  sql_attr_uint = sphinx_deleted
  sql_attr_uint = created_at
  sql_attr_uint = updated_at
  sql_attr_string = sphinx_internal_class
}

index user_core
{
  type = plain
  path = /home/adk/classifier/db/sphinx/test/user_core
  source = user_core_0
}

source xcategory_core_0
{
  type = pgsql
  sql_host = localhost
  sql_user = postgres
  sql_pass = 123456
  sql_db = classifier_test
  sql_query_pre = SET TIME ZONE UTC
  sql_query = SELECT "xcategories"."id" * 12 + 3 AS "id", "xcategories"."title" AS "title", "xcategories"."synonym" AS "synonym", "xcategories"."description" AS "description", "xcategories"."code" AS "code", "xcategories"."id" AS "sphinx_internal_id", 'Xcategory' AS "sphinx_internal_class", 0 AS "sphinx_deleted", "xcategories"."publish" AS "publish", extract(epoch from "xcategories"."version_date")::int AS "version_date", "xcategories"."xroot_id" AS "xroot_id", "xcategories"."user_id" AS "user_id", extract(epoch from "xcategories"."created_at")::int AS "created_at", extract(epoch from "xcategories"."updated_at")::int AS "updated_at" FROM "xcategories" WHERE ("xcategories"."id" BETWEEN $start AND $end) GROUP BY "xcategories"."id", "xcategories"."title", "xcategories"."synonym", "xcategories"."description", "xcategories"."code", "xcategories"."id", "xcategories"."publish", "xcategories"."version_date", "xcategories"."xroot_id", "xcategories"."user_id", "xcategories"."created_at", "xcategories"."updated_at"
  sql_query_range = SELECT COALESCE(MIN("xcategories"."id"), 1), COALESCE(MAX("xcategories"."id"), 1) FROM "xcategories"
  sql_attr_uint = sphinx_internal_id
  sql_attr_uint = sphinx_deleted
  sql_attr_uint = version_date
  sql_attr_uint = xroot_id
  sql_attr_uint = user_id
  sql_attr_uint = created_at
  sql_attr_uint = updated_at
  sql_attr_bool = publish
  sql_attr_string = sphinx_internal_class
  sql_field_string = title
}

index xcategory_core
{
  type = plain
  path = /home/adk/classifier/db/sphinx/test/xcategory_core
  source = xcategory_core_0
}

source xclass_core_0
{
  type = pgsql
  sql_host = localhost
  sql_user = postgres
  sql_pass = 123456
  sql_db = classifier_test
  sql_query_pre = SET TIME ZONE UTC
  sql_query = SELECT "xclasses"."id" * 12 + 4 AS "id", "xclasses"."title" AS "title", "xclasses"."synonym" AS "synonym", "xclasses"."description" AS "description", "xclasses"."code" AS "code", "xclasses"."full_code" AS "full_code", "xclasses"."id" AS "sphinx_internal_id", 'Xclass' AS "sphinx_internal_class", 0 AS "sphinx_deleted", extract(epoch from "xclasses"."version_date")::int AS "version_date", "xclasses"."publish" AS "publish", "xclasses"."xtype" AS "xtype", "xclasses"."position" AS "position", "xclasses"."ancestry" AS "ancestry", "xclasses"."ancestry_depth" AS "ancestry_depth", "xclasses"."xcategory_id" AS "xcategory_id", "xclasses"."user_id" AS "user_id", extract(epoch from "xclasses"."created_at")::int AS "created_at", extract(epoch from "xclasses"."updated_at")::int AS "updated_at" FROM "xclasses" WHERE ("xclasses"."id" BETWEEN $start AND $end) GROUP BY "xclasses"."id", "xclasses"."title", "xclasses"."synonym", "xclasses"."description", "xclasses"."code", "xclasses"."full_code", "xclasses"."id", "xclasses"."version_date", "xclasses"."publish", "xclasses"."xtype", "xclasses"."position", "xclasses"."ancestry", "xclasses"."ancestry_depth", "xclasses"."xcategory_id", "xclasses"."user_id", "xclasses"."created_at", "xclasses"."updated_at"
  sql_query_range = SELECT COALESCE(MIN("xclasses"."id"), 1), COALESCE(MAX("xclasses"."id"), 1) FROM "xclasses"
  sql_attr_uint = sphinx_internal_id
  sql_attr_uint = sphinx_deleted
  sql_attr_uint = version_date
  sql_attr_uint = ancestry_depth
  sql_attr_uint = xcategory_id
  sql_attr_uint = user_id
  sql_attr_uint = created_at
  sql_attr_uint = updated_at
  sql_attr_bool = publish
  sql_attr_bool = xtype
  sql_attr_string = sphinx_internal_class
  sql_attr_string = position
  sql_attr_string = ancestry
  sql_field_string = title
}

index xclass_core
{
  type = plain
  path = /home/adk/classifier/db/sphinx/test/xclass_core
  source = xclass_core_0
}

source xroot_core_0
{
  type = pgsql
  sql_host = localhost
  sql_user = postgres
  sql_pass = 123456
  sql_db = classifier_test
  sql_query_pre = SET TIME ZONE UTC
  sql_query = SELECT "xroots"."id" * 12 + 5 AS "id", "xroots"."title" AS "title", "xroots"."synonym" AS "synonym", "xroots"."description" AS "description", "xroots"."code" AS "code", "xroots"."id" AS "sphinx_internal_id", 'Xroot' AS "sphinx_internal_class", 0 AS "sphinx_deleted", extract(epoch from "xroots"."version_date")::int AS "version_date", "xroots"."publish" AS "publish", "xroots"."user_id" AS "user_id", extract(epoch from "xroots"."created_at")::int AS "created_at", extract(epoch from "xroots"."updated_at")::int AS "updated_at" FROM "xroots" WHERE ("xroots"."id" BETWEEN $start AND $end) GROUP BY "xroots"."id", "xroots"."title", "xroots"."synonym", "xroots"."description", "xroots"."code", "xroots"."id", "xroots"."version_date", "xroots"."publish", "xroots"."user_id", "xroots"."created_at", "xroots"."updated_at"
  sql_query_range = SELECT COALESCE(MIN("xroots"."id"), 1), COALESCE(MAX("xroots"."id"), 1) FROM "xroots"
  sql_attr_uint = sphinx_internal_id
  sql_attr_uint = sphinx_deleted
  sql_attr_uint = version_date
  sql_attr_uint = user_id
  sql_attr_uint = created_at
  sql_attr_uint = updated_at
  sql_attr_bool = publish
  sql_attr_string = sphinx_internal_class
  sql_field_string = title
}

index xroot_core
{
  type = plain
  path = /home/adk/classifier/db/sphinx/test/xroot_core
  source = xroot_core_0
}

index activity
{
  type = distributed
  local = activity_core
}

index property
{
  type = distributed
  local = property_core
}

index user
{
  type = distributed
  local = user_core
}

index xcategory
{
  type = distributed
  local = xcategory_core
}

index xclass
{
  type = distributed
  local = xclass_core
}

index xroot
{
  type = distributed
  local = xroot_core
}
